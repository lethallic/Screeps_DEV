1. 	TODO
        - createCreep. Calculate Move parts dynamically (body2) (difficult)
        - implement renew if creep is still "up to date" (memory => Available energy, construction time)
		- Scout upgrade controller - check if still exists + my (in case you unclaim controller for a reason)
        - source - define Container RoomPosition
        - miner build container
        - dropped minerals (outside container) doesn't get picked up
        - miner - if idle - repair container
        - miner - if link empty + container filled -> transfer to link.
        - miner with no free source is crashing code BANG BOOM BANG
    	- recalculate needed transporters (maybe easier when transporter2 is running)
		- prototype check if creep has same target (so not all creeps are running to the same ressource pile)
        -- OS Based Tasks -> Priority, how often, sleep
        -- Sell + Buy at Market
    	-- Scout could dismantle buildings in target room?
    	-- Harvest Power
		-- test attack behavior
		-- spawn defenders if attacked
    	-- Boost creeps
        -- Remote Mining ( there was a formula for calculation if RH makes sense)

   	BUGS
	    - (bug) internalTrade will send 20000 Resources from every terminal, even if there is enough already
		- (bug) when controller downgrades during construction, workers can't finish behavior construction
		- (bug) when creating Queues for resources, there is no check if creep is "on the way"
		
   	TESTING
		- (testing) Spawn only if room is full of energy - (Will room die?) - Make exception if transporter+builder = 0
        - (testing) 2 Upgraders if Dropped energy around Controller > 2000
    	
  	DONE
		- (done) Upgraders should only pickup energy, not minerals
		- (done) Use spawnCreep(body, name, [opts]), cancreate + create is deprecated
	  	- (done) (testing) behavior harvest works on empty source
		- (done) (testing) build queue for pickable resources (id, amount, type)(bonus: implement priority (power-mineral-energy))
		- (done) (testing) miner - walk to container, not source
        - (done) (testing) Resource Queue - Mineral in Container funktioniert nicht. 
        - (done) build queue for needed resources (id, amount, type)(bonus: implement priority (power-mineral-energy))
        - (done) Limit Upgrader Work parts in RCL 8
		- (done) behavior.harvest:11 /// return (creep.energy === creep.energyCapacity || source.energy === 0); /// TypeError: Cannot read property 'energy' of null
	    - (done) write general behavior for picking up resources. User Resource queue
        - (done) Update build creeps to always build max body.
		- (done) Separate role for upgrader in RCL 1+2+ (3?) (Activated in RCL2)
        - (done) Behavior Pickup Minerals (buggy - doesn't work)
        - (done) Behavior Harvest Minerals (needs spawn logic)
		- (done) Behavior Transport Minerals to Terminal
        - (done) (bug) Upgrade Rampart hört nicht auf wenn max erreicht ist. fix: Hardcoded value durch maxHits ersetzt.
		- (done) (bug) Fallback if no creeps in active room (Implemented but fails?) - Fix: Limit parts to 300 Energy
		- (done) (bug) Limit Tower repair - FIX: New Interval repairTower
	    - (done) When storage > 100000 energy - no more input. Fix -> maxE based on constants + rcl
		- (done) Check Scout Code
    	- (done) Upgrader Link -> Storage
    	- (done) Behavior Repair Container
    	- (done) Behavior Get_energy_container (done)
		- (done) (bug) Tower Repair + Heal (repair ready, but not activated in ControllerRoom)
		- (done) (bug) Filling Storage does not work with new checks. Why?	
    

2. Code Snippets

-------------------------------
/**

Module: prototype.Room.structures v1.5

Author: SemperRabbit

Date:   20180309-13,0411

Usage:  require('prototype.Room.structures');

​

This module will provide structure caching and extends the Room

  class' prototype to provide `room.controller`-like properties

  for all structure types. It will cache the object IDs of a

  room.find() grouped by type as IDs in global. Once the property

  is requested, it will chech the cache (and refresh if required),

  then return the appropriate objects by maping the cache's IDs

  into game objects for that tick.

​

Changelog:

1.0: Initial publish

1.1: Changed multipleList empty results from `null` to `[]`

     Bugfix: changed singleList returns from arrays to single objects or undefined

1.2: Added intra-tick caching in addition to inter-tick caching

1.3: Multiple bugfixes

1.4: Moved STRUCTURE_POWER_BANK to `multipleList` due to proof of *possibility* of multiple

        in same room.

1.5: Added CPU Profiling information for Room.prototype._checkRoomCache() starting on line 47

1.6: Added tick check for per-tick caching, in preperation for the potential "persistent Game

        object" update. Edits on lines 73, 77-83, 95, 99-105

*/

​

var roomStructures           = {};

var roomStructuresExpiration = {};

​

const CACHE_TIMEOUT = 50;

const CACHE_OFFSET  = 4;

​

const multipleList = [

    STRUCTURE_SPAWN,        STRUCTURE_EXTENSION,    STRUCTURE_ROAD,         STRUCTURE_WALL,

    STRUCTURE_RAMPART,      STRUCTURE_KEEPER_LAIR,  STRUCTURE_PORTAL,       STRUCTURE_LINK,

    STRUCTURE_TOWER,        STRUCTURE_LAB,          STRUCTURE_CONTAINER,	STRUCTURE_POWER_BANK,

];

​

const singleList = [

    STRUCTURE_OBSERVER,     STRUCTURE_POWER_SPAWN,  STRUCTURE_EXTRACTOR,	STRUCTURE_NUKER,

    //STRUCTURE_TERMINAL,   STRUCTURE_CONTROLLER,   STRUCTURE_STORAGE,

];

​

function getCacheExpiration(){

    return CACHE_TIMEOUT + Math.round((Math.random()*CACHE_OFFSET*2)-CACHE_OFFSET);

}

​

/********* CPU Profiling stats for Room.prototype._checkRoomCache ********** 

calls         time      avg        function

550106        5581.762  0.01015    Room._checkRoomCache

​

calls with cache reset: 4085

avg for cache reset:    0.137165

calls without reset:    270968

avg without reset:      0.003262

****************************************************************************/

Room.prototype._checkRoomCache = function _checkRoomCache(){

    // if cache is expired or doesn't exist

    if(!roomStructuresExpiration[this.name] || !roomStructures[this.name] || roomStructuresExpiration[this.name] < Game.time){

        roomStructuresExpiration[this.name] = Game.time + getCacheExpiration();

        roomStructures[this.name] = _.groupBy(this.find(FIND_STRUCTURES), s=>s.structureType);

        var i;

        for(i in roomStructures[this.name]){

            roomStructures[this.name][i] = _.map(roomStructures[this.name][i], s=>s.id);

        }

    }

}

​

multipleList.forEach(function(type){

    Object.defineProperty(Room.prototype, type+'s', {

        get: function(){

            if(this['_'+type+'s'] && this['_'+type+'s_ts'] === Game.time){

                return this['_'+type+'s'];

            } else {

                this._checkRoomCache();

                if(roomStructures[this.name][type]) {

					this['_'+type+'s_ts'] = Game.time;

                    return this['_'+type+'s'] = roomStructures[this.name][type].map(Game.getObjectById);

				} else {

					this['_'+type+'s_ts'] = Game.time;

                    return this['_'+type+'s'] = [];

				}

            }

        },

        set: function(){},

        enumerable: false,

        configurable: true,

    });

});

​

singleList.forEach(function(type){

    Object.defineProperty(Room.prototype, type, {

        get: function(){

            if(this['_'+type] && this['_'+type+'_ts'] === Game.time){

                return this['_'+type];

            } else {

                this._checkRoomCache();

                if(roomStructures[this.name][type]) {

					this['_'+type+'_ts'] = Game.time;

                    return this['_'+type] = Game.getObjectById(roomStructures[this.name][type][0]);

				} else {

					this['_'+type+'_ts'] = Game.time;

                    return this['_'+type] = undefined;

				}

            }

        },

        set: function(){},

        enumerable: false,

        configurable: true,

    });

});
----------------------------------
/**

 * Author:  Mototroller

 * Usage:   copy-paste

 * Licence: MIT

 * Version: 1.0

 *

 * Description:

 *  Simple prototype extention which allows every room object to use

 *  creep.say() method analogue: popup bubble with given text will be shown.

 *  Uses RoomVisual, so is should be enabled in GUI (enabled by default).

 */

​

/// @param {String} what - message will be displayed

RoomObject.prototype.say = function(what) {

    this.room.visual.line(this.pos.x, this.pos.y, this.pos.x + 1 - 0.2, this.pos.y - 1, {

        // Line from object to message bubble

        color: "#eeeeee",

        opacity: 0.9,

        width: 0.1

    }).circle(this.pos, {

        // Small dot marker at the top of object

        fill: "#aaffaa",

        opacity: 0.9

    }).text(what, this.pos.x + 1, this.pos.y - 1, {

        // Fake message, used to align background (to make black border)

        color: "black",

        opacity: 0.9,

        align: "left",

        font: "bold 0.6 Arial",

        backgroundColor: "black",

        backgroundPadding: 0.3

    }).text(what, this.pos.x + 1, this.pos.y - 1, {

        // Real message

        color: "black",

        opacity: 0.9,

        align: "left",

        font: "bold 0.6 Arial",

        backgroundColor: "#eeeeee",

        backgroundPadding: 0.2

    });
}
-----------------------------
/***

Two simple functions that accept either an object that possesses a .pos or a pos directly, and remove matching structures in range.  The range defaults to 1.

​

removeRoadsNear(input,range) removes roads.

removeEnemyNear(input,range) removes enemy Ramparts, Extensions, and Towers.

​

v1.0 Initial release, credit to warInternal for the inlining of forEach 20181012

​

*/

/*

	* @param {object} input - a RoomPosition object or another object containing a RoomPosition object

	* @param {number} range - a numeric range to check, defaults to 0

	*/

global.removeRoadsNear= function(input,range=1){

    //	sanitize the input for RoomPosition

	if (!(input instanceof RoomPosition)) {

            var inputpos =input.pos;

        } else {

            var inputpos = input

        }

	// create an array of matching structures

    let array= inputpos.findInRange(FIND_STRUCTURES, range, {filter: s => s.structureType ===  STRUCTURE_ROAD})

    // destroy the structures found above

	array.forEach(s => s.destroy())

}

/*

	* @param {object} input - a RoomPosition object or another object containing a RoomPosition object

	* @param {number} range - a numeric range to check, defaults to 0

	*/

global.removeEnemyNear= function(input,range=1){

        if (!(input instanceof RoomPosition)) {

            var inputpos = input.pos;

        } else {

            var inputpos = input;

        }

    let array= inputpos.findInRange(FIND_STRUCTURES, range, {filter: s => (

        !s.my && (

            ((s.structureType ===  STRUCTURE_EXTENSION || s.structureType ===  STRUCTURE_TOWER)

        && s.energy === 0)

        ||s.structureType === STRUCTURE_RAMPART

        )

        )})

    array.forEach(s => s.destroy())

}
-------------------------------
//ScreepsLiquidator
let prices = {
    XUH2O : 0.449,
    XKH2O : 1,
    XKHO2 : 0.6,
    XLH2O : 0.856,
    XLHO2 : 0.349,
    XZH2O : 0.3,
    XZHO2 : 0.48,
    XGH2O : 2.077,
    XGHO2 : 0.63,
};
//  energy : 0.012,
//  power : 0.393,
let orderAmount = 1000;
let priceReduction = 0.15;
for (let orderId in Game.market.orders) {
    if (Game.market.orders[orderId].remainingAmount == 0) {
        console.log('Cleaned up order ' + orderId);
        Game.market.cancelOrder(orderId);
    }
}
if (Object.keys(Game.market.orders).length >= 50) {
    if (Game.time % 20 === 0) { console.log('At max orders!') };
    return;
}
for (let roomName in Game.rooms) {
    let room = Game.rooms[roomName];
    if (room.terminal && room.controller && room.controller.my && room.controller.level >= 6) {
        let terminal = room.terminal;
        for (let type in terminal.store) {
            if (prices[type] === null) {
                console.log('No price for this');
            } else {
                let terminalAmount = terminal.store[type];
                let sellPrice = prices[type] * (1 - priceReduction);
                let matchingOrder = _.find(Game.market.orders, (order) => order.roomName == roomName && order.resourceType == type)
                if (matchingOrder) {
                    console.log('Already matching order ' + type + ' ' + JSON.stringify(matchingOrder));
                } else {
                    let res = Game.market.createOrder(ORDER_SELL, type, sellPrice, _.min([terminalAmount, orderAmount]), room.name);
                    console.log('Making sell order for ' + type + ' in ' + room.name + ' with res ' + res + ' at quantity ' + _.min([terminalAmount, orderAmount]));
                    if (res === ERR_FULL) {
                        console.log('At max orders!');
                        return;
                    }
                }
            }
        }
    }
}
------------------------------
creep.withdraw(creep.room.storage, _.findKey(creep.room.storage.store));
---------------------------
Game.market.getAllOrders({resourceType: RESOURCE_UTRIUM}); // fast
Game.market.getAllOrders({resourceType: RESOURCE_UTRIUM, type: ORDER_SELL}); // fast
Game.market.getAllOrders(); // slow
Game.market.getAllOrders(i => i.resourceType == RESOURCE_UTRIUM); //slow
---------------------------
placeContainer();
{
    if (this.room.controller.reservation &&
        /* reserved and not mine */
        this.room.controller.reservation.username != Game.structures[_.first(Object.keys(Game.structures))].owner.username) {
        // console.log(`MINER: Unable to place container in ${this.operation.name}, hostile reserved room`);
        return;
    }
    var startingPosition = this.findMinerStorage();
    if (!startingPosition) {
        startingPosition = this.room.find(FIND_MY_SPAWNS)[0];
    }
    if (!startingPosition) {
        startingPosition = this.room.find(FIND_CONSTRUCTION_SITES, { filter: (function (s) { return s.structureType === STRUCTURE_SPAWN; }) })[0];
    }
    if (!startingPosition)
        return;
    if (this.source.pos.findInRange(FIND_CONSTRUCTION_SITES, 1).length > 0)
        return;
    var ret = PathFinder.search(this.source.pos, [{ pos: startingPosition.pos, range: 1 }], {
        maxOps: 4000,
        swampCost: 2,
        plainCost: 2,
        roomCallback: function (roomName) {
            var room = Game.rooms[roomName];
            if (!room)
                return;
            var matrix = empire.traveler.getStructureMatrix(room);
            return matrix;
        }
    });
    if (ret.incomplete || ret.path.length === 0) {
        notifier.log("path used for container placement in " + this.operation.name + " incomplete, please investigate");
    }
    var position_1 = ret.path[0];
    var testPositions = _.sortBy(this.source.pos.openAdjacentSpots(true), function (p) { return p.getRangeTo(position_1); });
    for (var _i = 0, testPositions_1 = testPositions; _i < testPositions_1.length; _i++) {
        var testPosition = testPositions_1[_i];
        var sourcesInRange = testPosition.findInRange(FIND_SOURCES, 1);
        if (sourcesInRange.length > 1) {
            continue;
        }
        console.log("MINER: placed container in " + this.operation.name);
        testPosition.createConstructionSite(STRUCTURE_CONTAINER);
        return;
    }
    console.log("MINER: Unable to place container in " + this.operation.name);
}
---------------------------------------
// This is called during global reset to set up structure memory,
// because it doesn't need to be called often.
if(!Memory.structures) {
	console.log('[Memory] Initializing structure memory');
	Memory.structures = {}; 
}

// Adds structure memory to OwnedStructure things.
// Easier to reason about garbage collection in this implementation. 
Object.defineProperty(OwnedStructure.prototype, "memory", {
    get: function () {      
		if(!Memory.structures[this.id])
			Memory.structures[this.id] = {};
		return Memory.structures[this.id];
    },
	set: function(v) {
		return _.set(Memory, 'structures.' + this.id, v);
	},
	configurable: true,
	enumerable: false
});

// Call this periodically to garbage collect structure memory
// (I find once every 10k ticks is fine)
global.GCStructureMemory = function() {
   for (var id in Memory.structures )
			if(!Game.structures[id]) {
				console.log("Garbage collecting structure " + id + ', ' + JSON.stringify(Memory.structures[id]));
				delete Memory.structures[id];
			}
}
--------------------------------------------
Stick on global with `global.Log = require('Log');` and enjoy
/**
 * Log.js
 *
 * ES6 log class for logging screeps messages with color, where it makes sense.
 * @todo: abbr tag '<abbr title="World Health Organization">WHO</abbr>'
 * @todo: log groups / log levels?
 */
"use strict";

class Log {
	constructor() {
		throw new Error("Log is a static class");
	}

	static debug(msg, tag) {
		this.log(Log.LEVEL_DEBUG, msg, tag);
	}

	static info(msg, tag) {
		this.log(Log.LEVEL_INFO, msg, tag);
	}

	static warn(msg, tag) {
		this.log(Log.LEVEL_WARN, msg, tag);
	}

	static error(msg, tag) {
		this.log(Log.LEVEL_ERROR, msg, tag);
	}

	static success(msg, tag) {
		this.log(Log.LEVEL_SUCCESS, msg, tag);
	}

	/** */
	static log(level = Log.LEVEL_DEBUG, msg, tag) {
		var color = Log.color[level];
		if (tag && this.getLogLevel(tag) > level)
			return;
		this.toConsole(msg, color, tag);
	}

	/**
	 * HTML table in console
	 * ex: Log.table(['a','b'], [[1,2],[3,4]])
	 */
	static table(headers, rows) {

		let msg = '<table>';
		_.each(headers, h => msg += '<th width="50px">' + h + '</th>');
		_.each(rows, row => msg += '<tr>' + _.map(row, el => (`<th>${el}</th>`)) + '</tr>');
		msg += '</table>';
		// console.log(msg);
		return msg;
	}

	/** */
	static notify(msg, group = 0, color = 'red') {
		this.toConsole(msg, color);
		Game.notify(msg, group);
	/** */
	}

		if (!Memory.logging)
	static getLogLevel(tag) {
			Memory.logging = {};
		if (Memory.logging[tag] == null)
			return Log.LEVEL_WARN;
		return Memory.logging[tag];
	}

	/** */
	static toConsole(msg, color, tag) {
		if (tag)
			console.log(`<font color=${color}>[${tag}] ${msg}</font>`);
		else
			console.log(`<font color=${color}>${msg}</font>`);
	}

	/** */
	static progress(v, m) {
		return `<progress value="${v}" max="${m}"/>`;
	}

}

/** Log levels */
Log.LEVEL_DEBUG = 0;
Log.LEVEL_INFO = 1;
Log.LEVEL_WARN = 2;
Log.LEVEL_ERROR = 3;
Log.LEVEL_SUCCESS = 4;

/** Log colors */
Log.color = {
	[Log.LEVEL_DEBUG]: 'yellow',
	[Log.LEVEL_INFO]: 'cyan',
	[Log.LEVEL_WARN]: 'orange',
	[Log.LEVEL_ERROR]: 'red',
	[Log.LEVEL_SUCCESS]: 'green'
};

Object.freeze(Log);
Object.freeze(Log.color);

module.exports = Log;
----------------------------------------------
if (_.sum(creep.carry)) creep.transfer(target, _.last(Object.keys(creep.carry)))
----------------------------------------
global.UNIT_COST = (body) => _.sum(body, p => BODYPART_COST[p]);
global.UNIT_COST = function (body) { return _.sum(body, function (p) { return BODYPART_COST[p]; }); };
----------------------------------------
static exitPlanner(roomName, opts={}) {
		opts = _.defaults(opts, {
			visualize: true,
			commit: false,
		});
		var cm = new PathFinder.CostMatrix;
		var room = Game.rooms[roomName];
		// var visual = room.visual;
		var visual = new RoomVisual(roomName);
		if(room) {
			if(!opts.origin)
				opts.origin = _.create(RoomPosition.prototype, room.memory.origin);
			if(!opts.origin) {
				Log.warn('No origin');
				return;
			}
			var exits = room.find(FIND_EXIT).map(e => ({pos: e, range: 0}));
			room.find(FIND_STRUCTURES).forEach(({pos,structureType}) => {
				if(structureType === STRUCTURE_RAMPART || OBSTACLE_OBJECT_TYPES.includes(structureType))
					cm.set(pos.x,pos.y,255);
			});
		} else {
			console.log('No room object');
		}
		while(true) {
			var {path,incomplete} = PathFinder.search(opts.origin, exits, {roomCallback: () => cm, maxRooms: 1});
			if(incomplete)
				break;
			console.log(JSON.stringify(path));
			var pos = path[path.length-3];
			cm.set(pos.x,pos.y,255);
			var wallOrRampart = (pos.x + pos.y) % 2;
			if(opts.commit){
				var type =  (wallOrRampart?STRUCTURE_WALL:STRUCTURE_RAMPART);
				if(pos.hasStructure(type))
					continue;
				room.addToBuildQueue(pos,type);
			}
			if(opts.visualize) {
				visual.poly(path);
				// visual.circle(pos, {fill:(wallOrRampart?'black':'green'), opacity: 0.75});
				visual.circle(pos, {fill:'red', opacity: 0.75});
			}
		}
	}
----------------------------------------------------
class Pos {
	constructor(x, y) {
		this.x = x;
		this.y = y;
	}
}
Room.prototype.printRoomCosts = function(matrix, proportional = false,  aroundPos = false) {
	let x = 0, y = 0, maxCost = 5, val, line, cost, redHex, greenHex, color;
	let start = new Pos(Math.max(aroundPos && aroundPos.x - 3, 0) || 0,
					  Math.max(aroundPos && aroundPos.y - 3, 0) || 0);
	let end = new Pos(Math.min(aroundPos && aroundPos.x + 3, 49) || 49,
					  Math.min(aroundPos && aroundPos.y + 3, 49) || 49);
	console.log("costs:");
	
	if (proportional) {
	    let xP, yP
	    for (xP = start.x; xP <= end.x; xP++) {
	        for (yP = start.y; yP <= end.y; yP++) {
	            cost = matrix.get(xP, yP);
	            if (cost < 250 && cost > maxCost) {
	                maxCost = cost;
	            }
	        }
	    }
	    console.log(maxCost);
	}
	
	for (y = start.y; y <= end.y; y++) {
		line = '';
		for (x = start.x; x <= end.x; x++) {
		    val = Math.min(matrix.get(x, y) + 1, maxCost) * Math.floor(256 / maxCost);
		    redHex = (val).toString(16);
		    greenHex = (256 - val).toString(16);
		    color = ( redHex[1] ? redHex : '0' + (redHex[0] || '0') )+
		            (greenHex[1] ? greenHex : '0' + (greenHex[0] || '0') ) +
		            '00';
			line += '<a style="color: #' + color + '">███</a>';
		}
		console.log(line);
	}
}
----------------------------------------
	creep.pos.findClosestByRange(FIND_DROPPED_RESOURCES, {filter{resourceType:RESOURCE_POWER});
----------------------------------------------
	doStats: {
        run: function () {
            Memory.stats = {
                tick: Game.time,
                cpu: _.cloneDeep(Game.cpu),
                gcl: Game.gcl,
                constructionSites: _.size(Game.constructionSites),
                tokens: Game.resources.token,

                memory: {
                    used: RawMemory.get().length
                },

                market: {
                    credits: Game.market.credits,
                    num_orders: Game.market.orders ? Object.keys(Game.market.orders).length : 0,
                }

            }
        }
    }
-----------------------------------------------
	function mayReserveController(theController) {
    if (theController.owner) {
        return false;
    }
    if (!theController.reservation) {
        return true;
    }
    if (theController.reservation.username != 'Dissi') {
        return false;
    }
    if (theController.reservation.ticksToEnd < 2500) {
        return true;
    }
    return false;
}
-------------------------------------
global.spiralOut = function(n){
    let m=n+1;
    let result = [];
    for (let i=0; i<=49; i++ ){
        if (i % 2 === 0 || m > 49){
            result[i]=n;
            n--;
            continue;
        }
        result[i]=m;
        m++;
    }
    return result;
},
