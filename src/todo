1. 	TODO
    	- Remote Mining (check for goals, new behavior)
		- 2 Upgrader if Dropped energy around Controller > 5000 ?
		- If Extension is already target of another creep, take next extension.
		- Scout upgrade controller - check if still exists + my (in case you unclaim controller for a reason)
        - prototpye sourceHasLink (then don't get energy from there, miner is doing this..)
        - source - define Container RoomPosition
        - miner - if idle - repair container
        - miner - if link empty + container filled -> transfer to link.
        - recalculate needed transporters
        - build queue for needed resources (id, amount, type)(bonus: implement priority (power-mineral-energy))
        - prototype check if creep has same target (so not all creeps are running to the same ressource pile)
        - Update build creeps to always build max body.
		-- Sell + Buy at Market (check code at bottom of this file)
    	-- Scout could dismantle buildings in target room?
    	-- Harvest Power
		-- test attack behavior
		-- spawn defenders if attacked
    	-- Boost creeps
   	BUGS
	    - (bug) when controller downgrades during construction, workers can't finish behavior construction
   	TESTING
    	- (testing) miner - walk to container, not source
        - (testing) build queue for pickable resources (id, amount, type)(bonus: implement priority (power-mineral-energy))
  	DONE
	    - (done) Separate role for upgrader in RCL 1+2+ (3?) (Activated in RCL2)
        - (done) Behavior Pickup Minerals (buggy - doesn't work)
        - (done) Behavior Harvest Minerals (needs spawn logic)
		- (done) Behavior Transport Minerals to Terminal
        - (done) (bug) Upgrade Rampart hört nicht auf wenn max erreicht ist. fix: Hardcoded value durch maxHits ersetzt.
		- (done) (bug) Fallback if no creeps in active room (Implemented but fails?) - Fix: Limit parts to 300 Energy
		- (done) (bug) Limit Tower repair - FIX: New Interval repairTower
	    - (done) When storage > 100000 energy - no more input. Fix -> maxE based on constants + rcl
		- (done) Check Scout Code
    	- (done) Upgrader Link -> Storage
    	- (done) Behavior Repair Container
    	- (done) Behavior Get_energy_container (done)
		- (done) (bug) Tower Repair + Heal (repair ready, but not activated in ControllerRoom)
		- (done) (bug) Filling Storage does not work with new checks. Why?	
    

2. Code Snippets

Object.defineProperty(Source.prototype, “memory”, {
  configurable: true,
  get() {
    if (_.isUndefined(this.room.memory.sources)) {
      this.room.memory.sources = {};
    }
    return this.room.memory.sources[this.id] = this.room.memory.sources[this.id] || {};
  },
  set(value) {
    if (_.isUndefined(this.room.memory.sources)) {
      this.room.memory.sources = {};
    }
    if (!_.isObject(Memory.structure)) {
      throw new Error(“Could not set structure memory”);
    }
    this.room.memory.sources[this.id] = value;
  },
});

----------------------------------------
Object.defineProperty(Source.prototype, 'memory', {
    configurable: true,
    get: function() {
        if(_.isUndefined(Memory.mySourcesMemory)) {
            Memory.mySourcesMemory = {};
        }
        if(!_.isObject(Memory.mySourcesMemory)) {
            return undefined;
        }
        return Memory.mySourcesMemory[this.id] = 
                Memory.mySourcesMemory[this.id] || {};
    },
    set: function(value) {
        if(_.isUndefined(Memory.mySourcesMemory)) {
            Memory.mySourcesMemory = {};
        }
        if(!_.isObject(Memory.mySourcesMemory)) {
            throw new Error('Could not set source memory');
        }
        Memory.mySourcesMemory[this.id] = value;
    }
});

----------------------------------------
Object.defineProperty(Source.prototype, 'freeSpaceCount', {
    get: function () {
        if (this._freeSpaceCount == undefined) {
            if (this.memory.freeSpaceCount == undefined) {
                let freeSpaceCount = 0;
                [this.pos.x - 1, this.pos.x, this.pos.x + 1].forEach(x => {
                    [this.pos.y - 1, this.pos.y, this.pos.y + 1].forEach(y => {
                        if (Game.map.getTerrainAt(x, y, this.pos.roomName) != 'wall')
                                freeSpaceCount++;
                            }, this);
                    }, this);
                this.memory.freeSpaceCount = freeSpaceCount;
            }
            this._freeSpaceCount = this.memory.freeSpaceCount;
        }
        return this._freeSpaceCount;
    },
    enumerable: false,
    configurable: true
});
----------------------------------------

static exitPlanner(roomName, opts={}) {
		opts = _.defaults(opts, {
			visualize: true,
			commit: false,
		});
		var cm = new PathFinder.CostMatrix;
		var room = Game.rooms[roomName];
		// var visual = room.visual;
		var visual = new RoomVisual(roomName);
		if(room) {
			if(!opts.origin)
				opts.origin = _.create(RoomPosition.prototype, room.memory.origin);
			if(!opts.origin) {
				Log.warn('No origin');
				return;
			}
			var exits = room.find(FIND_EXIT).map(e => ({pos: e, range: 0}));
			room.find(FIND_STRUCTURES).forEach(({pos,structureType}) => {
				if(structureType === STRUCTURE_RAMPART || OBSTACLE_OBJECT_TYPES.includes(structureType))
					cm.set(pos.x,pos.y,255);
			});
		} else {
			console.log('No room object');
		}
		while(true) {
			var {path,incomplete} = PathFinder.search(opts.origin, exits, {roomCallback: () => cm, maxRooms: 1});
			if(incomplete)
				break;
			console.log(JSON.stringify(path));
			var pos = path[path.length-3];
			cm.set(pos.x,pos.y,255);
			var wallOrRampart = (pos.x + pos.y) % 2;
			if(opts.commit){
				var type =  (wallOrRampart?STRUCTURE_WALL:STRUCTURE_RAMPART);
				if(pos.hasStructure(type))
					continue;
				room.addToBuildQueue(pos,type);
			}
			if(opts.visualize) {
				visual.poly(path);
				// visual.circle(pos, {fill:(wallOrRampart?'black':'green'), opacity: 0.75});
				visual.circle(pos, {fill:'red', opacity: 0.75});
			}
		}
	}
----------------------------------------------------
class Pos {
	constructor(x, y) {
		this.x = x;
		this.y = y;
	}
}
Room.prototype.printRoomCosts = function(matrix, proportional = false,  aroundPos = false) {
	let x = 0, y = 0, maxCost = 5, val, line, cost, redHex, greenHex, color;
	let start = new Pos(Math.max(aroundPos && aroundPos.x - 3, 0) || 0,
					  Math.max(aroundPos && aroundPos.y - 3, 0) || 0);
	let end = new Pos(Math.min(aroundPos && aroundPos.x + 3, 49) || 49,
					  Math.min(aroundPos && aroundPos.y + 3, 49) || 49);
	console.log("costs:");
	
	if (proportional) {
	    let xP, yP
	    for (xP = start.x; xP <= end.x; xP++) {
	        for (yP = start.y; yP <= end.y; yP++) {
	            cost = matrix.get(xP, yP);
	            if (cost < 250 && cost > maxCost) {
	                maxCost = cost;
	            }
	        }
	    }
	    console.log(maxCost);
	}
	
	for (y = start.y; y <= end.y; y++) {
		line = '';
		for (x = start.x; x <= end.x; x++) {
		    val = Math.min(matrix.get(x, y) + 1, maxCost) * Math.floor(256 / maxCost);
		    redHex = (val).toString(16);
		    greenHex = (256 - val).toString(16);
		    color = ( redHex[1] ? redHex : '0' + (redHex[0] || '0') )+
		            (greenHex[1] ? greenHex : '0' + (greenHex[0] || '0') ) +
		            '00';
			line += '<a style="color: #' + color + '">███</a>';
		}
		console.log(line);
	}
}

	----------------------------------------
	const structureTimeToSaveFor = 13;
	Room.prototype.getStructures =
    function (structureType, filter) {
    if (!global[this.name]) global[this.name] = {};
        if (!global[this.name].structures || Game.time-global[this.name].structures.lc > structureTimeToSaveFor) {
            global[this.name].structures = {lc: Game.time};

            var grouped = _.groupBy(this.find(FIND_STRUCTURES), (s) => s.structureType);
            var mappedGroup = {};

            for (let group in grouped) mappedGroup[group] = _.map(grouped[group], (s) => {return s ? s.id : null});

            global[this.name].structures.structures = mappedGroup;
        }

        var needed = global[this.name].structures.structures[structureType].map(Game.getObjectById).filter(obj => obj !== null);
        return filter ? _.filter(needed, filter) : needed;
    };
	----------------------------------------------
	creep.pos.findClosestByRange(FIND_DROPPED_RESOURCES, {filter{resourceType:RESOURCE_POWER});
	----------------------------------------------
	doStats: {
        run: function () {
            Memory.stats = {
                tick: Game.time,
                cpu: _.cloneDeep(Game.cpu),
                gcl: Game.gcl,
                constructionSites: _.size(Game.constructionSites),
                tokens: Game.resources.token,

                memory: {
                    used: RawMemory.get().length
                },

                market: {
                    credits: Game.market.credits,
                    num_orders: Game.market.orders ? Object.keys(Game.market.orders).length : 0,
                }

            }
        }
    }
	-----------------------------------------------
	function mayReserveController(theController) {
    if (theController.owner) {
        return false;
    }
    if (!theController.reservation) {
        return true;
    }
    if (theController.reservation.username != 'Dissi') {
        return false;
    }
    if (theController.reservation.ticksToEnd < 2500) {
        return true;
    }
    return false;
}
-------------------------------------
Memory.config = Memory.config || {}`;
-------------------------------------
for (let resource in this.room.storage.store) {
    if (resource === RESOURCE_ENERGY || resource === RESOURCE_POWER) {
      continue;
    }
    this.withdraw(this.room.storage, resource);
  }
----------------------------------------
Object.defineProperty(Creep, 'friendly', { get: () => _.contains(alliance, this.owner.username); });
...
filter: (c)=> !c.friendly
----------------------------------------
global.spiralOut = function(n){
    let m=n+1;
    let result = [];
    for (let i=0; i<=49; i++ ){
        if (i % 2 === 0 || m > 49){
            result[i]=n;
            n--;
            continue;
        }
        result[i]=m;
        m++;
    }
    return result;
},
-------------------------------------------
const freeRange = 2;
var bestPos;
 
for (let x = 3; x < 46; x++) {
for (let y = 3; y < 46; y++) {
let pos = new RoomPosition(x, y, room.name);
 
let exits = pos.findInRange(FIND_EXIT, freeRange);
if (exits.length > 0) continue;
 
let structs = pos.findInRange(FIND_STRUCTURES, freeRange, {filter: (s) => s.structureType != STRUCTURE_ROAD});
if (structs.length > 0) continue;
 
let flags = pos.findInRange(FIND_FLAGS, 4);
if (flags.length > 0) continue;
 
let terrain = _.filter(room.lookForAtArea(LOOK_TERRAIN, y - freeRange, x - freeRange, y + freeRange, x + freeRange, true), (p) => p.type == 'terrain' && p.terrain == 'wall');
if (terrain.length > 0) continue;
 
let goodPos = new RoomPosition(x, y, room.name);
 
let toSource = [];
let toController;
 
_.forEach(room.find(FIND_SOURCES), (s) => {
toSource.push(room.findPath(goodPos, s.pos, {ignoreCreeps: true, ignoreRoads: true, maxRooms: 1}).length);
});
 
toController = room.findPath(goodPos, room.controller.pos, {ignoreCreeps: true, ignoreRoads: true, maxRooms: 1}).length;
 
let cnt = 0;
 
if (!bestPos) {
bestPos = {
x: goodPos.x,
y: goodPos.y,
c: toController,
s: toSource
}
}
 
for (let foo in toSource) {
if (bestPos.s[foo] > toSource[foo]) cnt++;
}
 
if (cnt >= 2 || (cnt >= 1 && toController <= bestPos.c) || toController*2 <= bestPos.c) {
bestPos = {
 
x: goodPos.x,
y: goodPos.y,
c: toController,
s: toSource
}
}
}
}
 
room.createFlag(bestPos.x, bestPos.y, 'distrSquare:' + room.name, COLOR_PURPLE, COLOR_BLUE);
---------------------------------
    // Get orders and filter them
    let orders = Game.market.getAllOrders().filter(order =>
        order.type === ORDER_BUY                    // Only check sell orders
        && order.resourceType !== RESOURCE_ENERGY   // Don't sell energy
        && order.remainingAmount > minAmount        // Only look at orders with 1000+ units
        && this.store[order.resourceType] >= 1000); // terminal must have at least 1k of this resource
    // Compute, map and filter on profit
    orders = orders.map((order) => {
        let amount = Math.min(order.remainingAmount, this.store[order.resourceType]);
        let fee = Game.market.calcTransactionCost(amount, this.room.name, order.roomName);
        let profit = order.price + (fee * energyPrice / amount);
        return _.merge(order, { fee, profit, amount });
    });
    orders = orders.filter(order => order.profit > cfg.get(`market.minProfit.${order.resourceType}`));
    // Get best order and deal
    if (orders.length === 0) return notif.debug('Found no deal in buy orders.', this.room.name);
    let bestOrder = _.min(orders, 'profit');
    return this.deal(bestOrder);
---------------------------------------
    _.invoke(Game.constructionSites, 'remove')
------------------------------------------
    Object.defineProperty(Source.prototype, "usableFields", {
  get: function (): number {
    let ret = 0;
    if (!this.memory.usableFields) {
      ret = 9 - _.countBy(this.lookForNear(LOOK_TERRAIN, true), 'terrain')['wall'];
      this.memory.usableFields = ret;
    } else {
      ret = this.memory.usableFields;
    }
    return ret;
  },
  configurable: true,
});