1. 	TODO
    	- Behavior Transport Minerals to Terminal
    	- Behavior Harvest Minerals
		- When storage > 100000 energy -> Prefer other link :-)
		- Remote Mining (check for goals, new behavior)
		- centralize all find operations in ControllerRoom
    	- Rework Scout. 1 scout with claim parts, rest without (Claim Part Creeps die quicker and are expensive)
		- 2 Upgrader if Dropped energy around Controller > 5000 ?
		- If Extension is already target of another creep, take next extension.
		- Scout upgrade controller - check if still exists + my (in case you unclaim controller for a reason)
		-- Sell + Buy at Market
    	-- Scout could dismantle buildings in target room?
    	-- Harvest Power
    	-- renew boosted creeps
		-- test attack behavior
		-- spawn defenders if attacked
    	-- Boost creeps
   	BUGS
	    - (bug) when controller downgrades during construction, workers can't finish behavior construction
   	TESTING
    	- (test) Separate role for upgrader in RCL 1+2+ (3?) (Activated in RCL2)
    	- (test) Behavior Pickup Minerals (only dropped minerals - nope, walks directly to mineral source)
  	DONE
	    - (done) (bug) Upgrade Rampart hört nicht auf wenn max erreicht ist. fix: Hardcoded value durch maxHits ersetzt.
		- (done) (bug) Fallback if no creeps in active room (Implemented but fails?) - Fix: Limit parts to 300 Energy
		- (done) (bug) Limit Tower repair - FIX: New Interval repairTower
	    - (done) When storage > 100000 energy - no more input. Fix -> maxE based on constants + rcl
		- (done) Check Scout Code
    	- (done) Upgrader Link -> Storage
    	- (done) Behavior Repair Container
    	- (done) Behavior Get_energy_container (done)
		- (done) (bug) Tower Repair + Heal (repair ready, but not activated in ControllerRoom)
		- (done) (bug) Filling Storage does not work with new checks. Why?	
    

2. Code Snippets

Object.defineProperty(Source.prototype, “memory”, {
  configurable: true,
  get() {
    if (_.isUndefined(this.room.memory.sources)) {
      this.room.memory.sources = {};
    }
    return this.room.memory.sources[this.id] = this.room.memory.sources[this.id] || {};
  },
  set(value) {
    if (_.isUndefined(this.room.memory.sources)) {
      this.room.memory.sources = {};
    }
    if (!_.isObject(Memory.structure)) {
      throw new Error(“Could not set structure memory”);
    }
    this.room.memory.sources[this.id] = value;
  },
});

----------------------------------------
Object.defineProperty(Source.prototype, 'memory', {
    configurable: true,
    get: function() {
        if(_.isUndefined(Memory.mySourcesMemory)) {
            Memory.mySourcesMemory = {};
        }
        if(!_.isObject(Memory.mySourcesMemory)) {
            return undefined;
        }
        return Memory.mySourcesMemory[this.id] = 
                Memory.mySourcesMemory[this.id] || {};
    },
    set: function(value) {
        if(_.isUndefined(Memory.mySourcesMemory)) {
            Memory.mySourcesMemory = {};
        }
        if(!_.isObject(Memory.mySourcesMemory)) {
            throw new Error('Could not set source memory');
        }
        Memory.mySourcesMemory[this.id] = value;
    }
});

----------------------------------------
Object.defineProperty(Source.prototype, 'freeSpaceCount', {
    get: function () {
        if (this._freeSpaceCount == undefined) {
            if (this.memory.freeSpaceCount == undefined) {
                let freeSpaceCount = 0;
                [this.pos.x - 1, this.pos.x, this.pos.x + 1].forEach(x => {
                    [this.pos.y - 1, this.pos.y, this.pos.y + 1].forEach(y => {
                        if (Game.map.getTerrainAt(x, y, this.pos.roomName) != 'wall')
                                freeSpaceCount++;
                            }, this);
                    }, this);
                this.memory.freeSpaceCount = freeSpaceCount;
            }
            this._freeSpaceCount = this.memory.freeSpaceCount;
        }
        return this._freeSpaceCount;
    },
    enumerable: false,
    configurable: true
});
----------------------------------------

static exitPlanner(roomName, opts={}) {
		opts = _.defaults(opts, {
			visualize: true,
			commit: false,
		});
		var cm = new PathFinder.CostMatrix;
		var room = Game.rooms[roomName];
		// var visual = room.visual;
		var visual = new RoomVisual(roomName);
		if(room) {
			if(!opts.origin)
				opts.origin = _.create(RoomPosition.prototype, room.memory.origin);
			if(!opts.origin) {
				Log.warn('No origin');
				return;
			}
			var exits = room.find(FIND_EXIT).map(e => ({pos: e, range: 0}));
			room.find(FIND_STRUCTURES).forEach(({pos,structureType}) => {
				if(structureType === STRUCTURE_RAMPART || OBSTACLE_OBJECT_TYPES.includes(structureType))
					cm.set(pos.x,pos.y,255);
			});
		} else {
			console.log('No room object');
		}
		while(true) {
			var {path,incomplete} = PathFinder.search(opts.origin, exits, {roomCallback: () => cm, maxRooms: 1});
			if(incomplete)
				break;
			console.log(JSON.stringify(path));
			var pos = path[path.length-3];
			cm.set(pos.x,pos.y,255);
			var wallOrRampart = (pos.x + pos.y) % 2;
			if(opts.commit){
				var type =  (wallOrRampart?STRUCTURE_WALL:STRUCTURE_RAMPART);
				if(pos.hasStructure(type))
					continue;
				room.addToBuildQueue(pos,type);
			}
			if(opts.visualize) {
				visual.poly(path);
				// visual.circle(pos, {fill:(wallOrRampart?'black':'green'), opacity: 0.75});
				visual.circle(pos, {fill:'red', opacity: 0.75});
			}
		}
	}
----------------------------------------------------
class Pos {
	constructor(x, y) {
		this.x = x;
		this.y = y;
	}
}
Room.prototype.printRoomCosts = function(matrix, proportional = false,  aroundPos = false) {
	let x = 0, y = 0, maxCost = 5, val, line, cost, redHex, greenHex, color;
	let start = new Pos(Math.max(aroundPos && aroundPos.x - 3, 0) || 0,
					  Math.max(aroundPos && aroundPos.y - 3, 0) || 0);
	let end = new Pos(Math.min(aroundPos && aroundPos.x + 3, 49) || 49,
					  Math.min(aroundPos && aroundPos.y + 3, 49) || 49);
	console.log("costs:");
	
	if (proportional) {
	    let xP, yP
	    for (xP = start.x; xP <= end.x; xP++) {
	        for (yP = start.y; yP <= end.y; yP++) {
	            cost = matrix.get(xP, yP);
	            if (cost < 250 && cost > maxCost) {
	                maxCost = cost;
	            }
	        }
	    }
	    console.log(maxCost);
	}
	
	for (y = start.y; y <= end.y; y++) {
		line = '';
		for (x = start.x; x <= end.x; x++) {
		    val = Math.min(matrix.get(x, y) + 1, maxCost) * Math.floor(256 / maxCost);
		    redHex = (val).toString(16);
		    greenHex = (256 - val).toString(16);
		    color = ( redHex[1] ? redHex : '0' + (redHex[0] || '0') )+
		            (greenHex[1] ? greenHex : '0' + (greenHex[0] || '0') ) +
		            '00';
			line += '<a style="color: #' + color + '">███</a>';
		}
		console.log(line);
	}
}

	----------------------------------------
	const structureTimeToSaveFor = 13;
	Room.prototype.getStructures =
    function (structureType, filter) {
    if (!global[this.name]) global[this.name] = {};
        if (!global[this.name].structures || Game.time-global[this.name].structures.lc > structureTimeToSaveFor) {
            global[this.name].structures = {lc: Game.time};

            var grouped = _.groupBy(this.find(FIND_STRUCTURES), (s) => s.structureType);
            var mappedGroup = {};

            for (let group in grouped) mappedGroup[group] = _.map(grouped[group], (s) => {return s ? s.id : null});

            global[this.name].structures.structures = mappedGroup;
        }

        var needed = global[this.name].structures.structures[structureType].map(Game.getObjectById).filter(obj => obj !== null);
        return filter ? _.filter(needed, filter) : needed;
    };
	----------------------------------------------
	creep.pos.findClosestByRange(FIND_DROPPED_RESOURCES, {filter{resourceType:RESOURCE_POWER});
	----------------------------------------------
	doStats: {
        run: function () {
            Memory.stats = {
                tick: Game.time,
                cpu: _.cloneDeep(Game.cpu),
                gcl: Game.gcl,
                constructionSites: _.size(Game.constructionSites),
                tokens: Game.resources.token,

                memory: {
                    used: RawMemory.get().length
                },

                market: {
                    credits: Game.market.credits,
                    num_orders: Game.market.orders ? Object.keys(Game.market.orders).length : 0,
                }

            }
        }
    }
	-----------------------------------------------
	function mayReserveController(theController) {
    if (theController.owner) {
        return false;
    }
    if (!theController.reservation) {
        return true;
    }
    if (theController.reservation.username != 'Dissi') {
        return false;
    }
    if (theController.reservation.ticksToEnd < 2500) {
        return true;
    }
    return false;
}