1. 	TODO
    	- Remote Mining (check for goals, new behavior)
		- 2 Upgrader if Dropped energy around Controller > 5000 ?
		- If Extension is already target of another creep, take next extension.
		- Scout upgrade controller - check if still exists + my (in case you unclaim controller for a reason)
        - prototpye sourceHasLink (then don't get energy from there, miner is doing this..)
        - source - define Container RoomPosition
        - miner - if idle - repair container
        - miner - if link empty + container filled -> transfer to link.
        - recalculate needed transporters
        - build queue for needed resources (id, amount, type)(bonus: implement priority (power-mineral-energy))
        - prototype check if creep has same target (so not all creeps are running to the same ressource pile)
        - Update build creeps to always build max body.
		-- Sell + Buy at Market (check code at bottom of this file)
    	-- Scout could dismantle buildings in target room?
    	-- Harvest Power
		-- test attack behavior
		-- spawn defenders if attacked
    	-- Boost creeps
   	BUGS
	    - (bug) when controller downgrades during construction, workers can't finish behavior construction
   	TESTING
    	- (testing) miner - walk to container, not source
        - (testing) build queue for pickable resources (id, amount, type)(bonus: implement priority (power-mineral-energy))
  	DONE
	    - (done) Separate role for upgrader in RCL 1+2+ (3?) (Activated in RCL2)
        - (done) Behavior Pickup Minerals (buggy - doesn't work)
        - (done) Behavior Harvest Minerals (needs spawn logic)
		- (done) Behavior Transport Minerals to Terminal
        - (done) (bug) Upgrade Rampart hört nicht auf wenn max erreicht ist. fix: Hardcoded value durch maxHits ersetzt.
		- (done) (bug) Fallback if no creeps in active room (Implemented but fails?) - Fix: Limit parts to 300 Energy
		- (done) (bug) Limit Tower repair - FIX: New Interval repairTower
	    - (done) When storage > 100000 energy - no more input. Fix -> maxE based on constants + rcl
		- (done) Check Scout Code
    	- (done) Upgrader Link -> Storage
    	- (done) Behavior Repair Container
    	- (done) Behavior Get_energy_container (done)
		- (done) (bug) Tower Repair + Heal (repair ready, but not activated in ControllerRoom)
		- (done) (bug) Filling Storage does not work with new checks. Why?	
    

2. Code Snippets

----------------------------------------
global.UNIT_COST = (body) => _.sum(body, p => BODYPART_COST[p]);
----------------------------------------
let cs = _.find(creep.pos.lookFor(LOOK_CONSTRUCTION_SITES), s => s.structureType === STRUCTURE_ROAD);
----------------------------------------
_.map( yourLookCall(), 'structure' )
----------------------------------------
global.whatsInTerminals = function() {
        let myUsername = Game.spawns[Object.keys(Game.spawns)[0]].owner.username;
        let roomData = {};
        let sums = {};
        let rooms = _.filter(Game.rooms, (r) => {
            if(r.controller 
               && r.controller.my
               && r.terminal) {
                return true;
            }
        })
        _.forEach(rooms, (r) => {
            roomData[r.name] = roomData[r.name] || {};
            _.forEach(r.terminal.store, (quantity, item) => {
                sums[item] = sums[item] || 0;
                sums[item] = sums[item] + quantity;
                roomData[r.name][item] = quantity;
            })
        })
        console.log('Room Data:', JSON.stringify(roomData, null, 3));
        console.log('Totals:', JSON.stringify(sums, null, 3));
    }
----------------------------------------
static exitPlanner(roomName, opts={}) {
		opts = _.defaults(opts, {
			visualize: true,
			commit: false,
		});
		var cm = new PathFinder.CostMatrix;
		var room = Game.rooms[roomName];
		// var visual = room.visual;
		var visual = new RoomVisual(roomName);
		if(room) {
			if(!opts.origin)
				opts.origin = _.create(RoomPosition.prototype, room.memory.origin);
			if(!opts.origin) {
				Log.warn('No origin');
				return;
			}
			var exits = room.find(FIND_EXIT).map(e => ({pos: e, range: 0}));
			room.find(FIND_STRUCTURES).forEach(({pos,structureType}) => {
				if(structureType === STRUCTURE_RAMPART || OBSTACLE_OBJECT_TYPES.includes(structureType))
					cm.set(pos.x,pos.y,255);
			});
		} else {
			console.log('No room object');
		}
		while(true) {
			var {path,incomplete} = PathFinder.search(opts.origin, exits, {roomCallback: () => cm, maxRooms: 1});
			if(incomplete)
				break;
			console.log(JSON.stringify(path));
			var pos = path[path.length-3];
			cm.set(pos.x,pos.y,255);
			var wallOrRampart = (pos.x + pos.y) % 2;
			if(opts.commit){
				var type =  (wallOrRampart?STRUCTURE_WALL:STRUCTURE_RAMPART);
				if(pos.hasStructure(type))
					continue;
				room.addToBuildQueue(pos,type);
			}
			if(opts.visualize) {
				visual.poly(path);
				// visual.circle(pos, {fill:(wallOrRampart?'black':'green'), opacity: 0.75});
				visual.circle(pos, {fill:'red', opacity: 0.75});
			}
		}
	}
----------------------------------------------------
class Pos {
	constructor(x, y) {
		this.x = x;
		this.y = y;
	}
}
Room.prototype.printRoomCosts = function(matrix, proportional = false,  aroundPos = false) {
	let x = 0, y = 0, maxCost = 5, val, line, cost, redHex, greenHex, color;
	let start = new Pos(Math.max(aroundPos && aroundPos.x - 3, 0) || 0,
					  Math.max(aroundPos && aroundPos.y - 3, 0) || 0);
	let end = new Pos(Math.min(aroundPos && aroundPos.x + 3, 49) || 49,
					  Math.min(aroundPos && aroundPos.y + 3, 49) || 49);
	console.log("costs:");
	
	if (proportional) {
	    let xP, yP
	    for (xP = start.x; xP <= end.x; xP++) {
	        for (yP = start.y; yP <= end.y; yP++) {
	            cost = matrix.get(xP, yP);
	            if (cost < 250 && cost > maxCost) {
	                maxCost = cost;
	            }
	        }
	    }
	    console.log(maxCost);
	}
	
	for (y = start.y; y <= end.y; y++) {
		line = '';
		for (x = start.x; x <= end.x; x++) {
		    val = Math.min(matrix.get(x, y) + 1, maxCost) * Math.floor(256 / maxCost);
		    redHex = (val).toString(16);
		    greenHex = (256 - val).toString(16);
		    color = ( redHex[1] ? redHex : '0' + (redHex[0] || '0') )+
		            (greenHex[1] ? greenHex : '0' + (greenHex[0] || '0') ) +
		            '00';
			line += '<a style="color: #' + color + '">███</a>';
		}
		console.log(line);
	}
}

----------------------------------------
	const structureTimeToSaveFor = 13;
	Room.prototype.getStructures =
    function (structureType, filter) {
    if (!global[this.name]) global[this.name] = {};
        if (!global[this.name].structures || Game.time-global[this.name].structures.lc > structureTimeToSaveFor) {
            global[this.name].structures = {lc: Game.time};

            var grouped = _.groupBy(this.find(FIND_STRUCTURES), (s) => s.structureType);
            var mappedGroup = {};

            for (let group in grouped) mappedGroup[group] = _.map(grouped[group], (s) => {return s ? s.id : null});

            global[this.name].structures.structures = mappedGroup;
        }

        var needed = global[this.name].structures.structures[structureType].map(Game.getObjectById).filter(obj => obj !== null);
        return filter ? _.filter(needed, filter) : needed;
    };
----------------------------------------------
	creep.pos.findClosestByRange(FIND_DROPPED_RESOURCES, {filter{resourceType:RESOURCE_POWER});
----------------------------------------------
	doStats: {
        run: function () {
            Memory.stats = {
                tick: Game.time,
                cpu: _.cloneDeep(Game.cpu),
                gcl: Game.gcl,
                constructionSites: _.size(Game.constructionSites),
                tokens: Game.resources.token,

                memory: {
                    used: RawMemory.get().length
                },

                market: {
                    credits: Game.market.credits,
                    num_orders: Game.market.orders ? Object.keys(Game.market.orders).length : 0,
                }

            }
        }
    }
-----------------------------------------------
	function mayReserveController(theController) {
    if (theController.owner) {
        return false;
    }
    if (!theController.reservation) {
        return true;
    }
    if (theController.reservation.username != 'Dissi') {
        return false;
    }
    if (theController.reservation.ticksToEnd < 2500) {
        return true;
    }
    return false;
}
-------------------------------------
Memory.config = Memory.config || {}`;
----------------------------------------
global.spiralOut = function(n){
    let m=n+1;
    let result = [];
    for (let i=0; i<=49; i++ ){
        if (i % 2 === 0 || m > 49){
            result[i]=n;
            n--;
            continue;
        }
        result[i]=m;
        m++;
    }
    return result;
},
------------------------------------------
    // Get orders and filter them
    let orders = Game.market.getAllOrders().filter(order =>
        order.type === ORDER_BUY                    // Only check sell orders
        && order.resourceType !== RESOURCE_ENERGY   // Don't sell energy
        && order.remainingAmount > minAmount        // Only look at orders with 1000+ units
        && this.store[order.resourceType] >= 1000); // terminal must have at least 1k of this resource
    // Compute, map and filter on profit
    orders = orders.map((order) => {
        let amount = Math.min(order.remainingAmount, this.store[order.resourceType]);
        let fee = Game.market.calcTransactionCost(amount, this.room.name, order.roomName);
        let profit = order.price + (fee * energyPrice / amount);
        return _.merge(order, { fee, profit, amount });
    });
    orders = orders.filter(order => order.profit > cfg.get(`market.minProfit.${order.resourceType}`));
    // Get best order and deal
    if (orders.length === 0) return notif.debug('Found no deal in buy orders.', this.room.name);
    let bestOrder = _.min(orders, 'profit');
    return this.deal(bestOrder);
---------------------------------------
    _.invoke(Game.constructionSites, 'remove')
------------------------------------------
    Object.defineProperty(Source.prototype, "usableFields", {
  get: function (): number {
    let ret = 0;
    if (!this.memory.usableFields) {
      ret = 9 - _.countBy(this.lookForNear(LOOK_TERRAIN, true), 'terrain')['wall'];
      this.memory.usableFields = ret;
    } else {
      ret = this.memory.usableFields;
    }
    return ret;
  },
  configurable: true,
});