1. 	TODO
		- miner with no free source is crashing code BANG BOOM BANG
		- Upgraders should only pickup energy, not minerals
    	- Remote Mining (check for goals, new behavior)
		- Remote Transport (for mining and abadoned rooms)
		- 2 Upgrader if Dropped energy around Controller > 5000 ?
		- Scout upgrade controller - check if still exists + my (in case you unclaim controller for a reason)
        - source - define Container RoomPosition
        - miner - if idle - repair container
        - miner - if link empty + container filled -> transfer to link.
        - recalculate needed transporters
		- createCreep. Calculate Move parts dynamically (body2)
        - prototype check if creep has same target (so not all creeps are running to the same ressource pile)
        -- Sell + Buy at Market
    	-- Scout could dismantle buildings in target room?
    	-- Harvest Power
		-- test attack behavior
		-- spawn defenders if attacked
    	-- Boost creeps
   	BUGS
	    - (bug) internalTrade will send 20000 Resources from every terminal, even if there is enough already
		- (bug) when controller downgrades during construction, workers can't finish behavior construction
		- (bug) when creating Queues for resources, there is no check if creep is "on the way"
		
   	TESTING
    	- (testing) ControllerRoom:329
				let containerId = this.getController().memory.container || null;
		        TypeError: Cannot read property 'memory' of null
  	DONE
		- (done) Use spawnCreep(body, name, [opts]), cancreate + create is deprecated
	  	- (done) (testing) behavior harvest works on empty source
		- (done) (testing) build queue for pickable resources (id, amount, type)(bonus: implement priority (power-mineral-energy))
		- (done) (testing) miner - walk to container, not source
        - (done) (testing) Resource Queue - Mineral in Container funktioniert nicht. 
        - (done) build queue for needed resources (id, amount, type)(bonus: implement priority (power-mineral-energy))
        - (done) Limit Upgrader Work parts in RCL 8
		- (done) behavior.harvest:11 /// return (creep.energy === creep.energyCapacity || source.energy === 0); /// TypeError: Cannot read property 'energy' of null
	    - (done) write general behavior for picking up resources. User Resource queue
        - (done) Update build creeps to always build max body.
		- (done) Separate role for upgrader in RCL 1+2+ (3?) (Activated in RCL2)
        - (done) Behavior Pickup Minerals (buggy - doesn't work)
        - (done) Behavior Harvest Minerals (needs spawn logic)
		- (done) Behavior Transport Minerals to Terminal
        - (done) (bug) Upgrade Rampart hÃ¶rt nicht auf wenn max erreicht ist. fix: Hardcoded value durch maxHits ersetzt.
		- (done) (bug) Fallback if no creeps in active room (Implemented but fails?) - Fix: Limit parts to 300 Energy
		- (done) (bug) Limit Tower repair - FIX: New Interval repairTower
	    - (done) When storage > 100000 energy - no more input. Fix -> maxE based on constants + rcl
		- (done) Check Scout Code
    	- (done) Upgrader Link -> Storage
    	- (done) Behavior Repair Container
    	- (done) Behavior Get_energy_container (done)
		- (done) (bug) Tower Repair + Heal (repair ready, but not activated in ControllerRoom)
		- (done) (bug) Filling Storage does not work with new checks. Why?	
    

2. Code Snippets

//ScreepsLiquidator
let prices = {
    XUH2O : 0.449,
    XKH2O : 1,
    XKHO2 : 0.6,
    XLH2O : 0.856,
    XLHO2 : 0.349,
    XZH2O : 0.3,
    XZHO2 : 0.48,
    XGH2O : 2.077,
    XGHO2 : 0.63,
};
//  energy : 0.012,
//  power : 0.393,
let orderAmount = 1000;
let priceReduction = 0.15;
for (let orderId in Game.market.orders) {
    if (Game.market.orders[orderId].remainingAmount == 0) {
        console.log('Cleaned up order ' + orderId);
        Game.market.cancelOrder(orderId);
    }
}
if (Object.keys(Game.market.orders).length >= 50) {
    if (Game.time % 20 === 0) { console.log('At max orders!') };
    return;
}
for (let roomName in Game.rooms) {
    let room = Game.rooms[roomName];
    if (room.terminal && room.controller && room.controller.my && room.controller.level >= 6) {
        let terminal = room.terminal;
        for (let type in terminal.store) {
            if (prices[type] === null) {
                console.log('No price for this');
            } else {
                let terminalAmount = terminal.store[type];
                let sellPrice = prices[type] * (1 - priceReduction);
                let matchingOrder = _.find(Game.market.orders, (order) => order.roomName == roomName && order.resourceType == type)
                if (matchingOrder) {
                    console.log('Already matching order ' + type + ' ' + JSON.stringify(matchingOrder));
                } else {
                    let res = Game.market.createOrder(ORDER_SELL, type, sellPrice, _.min([terminalAmount, orderAmount]), room.name);
                    console.log('Making sell order for ' + type + ' in ' + room.name + ' with res ' + res + ' at quantity ' + _.min([terminalAmount, orderAmount]));
                    if (res === ERR_FULL) {
                        console.log('At max orders!');
                        return;
                    }
                }
            }
        }
    }
}
------------------------------
creep.withdraw(creep.room.storage, _.findKey(creep.room.storage.store));
---------------------------
Game.market.getAllOrders({resourceType: RESOURCE_UTRIUM}); // fast
Game.market.getAllOrders({resourceType: RESOURCE_UTRIUM, type: ORDER_SELL}); // fast
Game.market.getAllOrders(); // slow
Game.market.getAllOrders(i => i.resourceType == RESOURCE_UTRIUM); //slow
---------------------------
placeContainer();
{
    if (this.room.controller.reservation &&
        /* reserved and not mine */
        this.room.controller.reservation.username != Game.structures[_.first(Object.keys(Game.structures))].owner.username) {
        // console.log(`MINER: Unable to place container in ${this.operation.name}, hostile reserved room`);
        return;
    }
    var startingPosition = this.findMinerStorage();
    if (!startingPosition) {
        startingPosition = this.room.find(FIND_MY_SPAWNS)[0];
    }
    if (!startingPosition) {
        startingPosition = this.room.find(FIND_CONSTRUCTION_SITES, { filter: (function (s) { return s.structureType === STRUCTURE_SPAWN; }) })[0];
    }
    if (!startingPosition)
        return;
    if (this.source.pos.findInRange(FIND_CONSTRUCTION_SITES, 1).length > 0)
        return;
    var ret = PathFinder.search(this.source.pos, [{ pos: startingPosition.pos, range: 1 }], {
        maxOps: 4000,
        swampCost: 2,
        plainCost: 2,
        roomCallback: function (roomName) {
            var room = Game.rooms[roomName];
            if (!room)
                return;
            var matrix = empire.traveler.getStructureMatrix(room);
            return matrix;
        }
    });
    if (ret.incomplete || ret.path.length === 0) {
        notifier.log("path used for container placement in " + this.operation.name + " incomplete, please investigate");
    }
    var position_1 = ret.path[0];
    var testPositions = _.sortBy(this.source.pos.openAdjacentSpots(true), function (p) { return p.getRangeTo(position_1); });
    for (var _i = 0, testPositions_1 = testPositions; _i < testPositions_1.length; _i++) {
        var testPosition = testPositions_1[_i];
        var sourcesInRange = testPosition.findInRange(FIND_SOURCES, 1);
        if (sourcesInRange.length > 1) {
            continue;
        }
        console.log("MINER: placed container in " + this.operation.name);
        testPosition.createConstructionSite(STRUCTURE_CONTAINER);
        return;
    }
    console.log("MINER: Unable to place container in " + this.operation.name);
}
---------------------------------------
// This is called during global reset to set up structure memory,
// because it doesn't need to be called often.
if(!Memory.structures) {
	console.log('[Memory] Initializing structure memory');
	Memory.structures = {}; 
}

// Adds structure memory to OwnedStructure things.
// Easier to reason about garbage collection in this implementation. 
Object.defineProperty(OwnedStructure.prototype, "memory", {
    get: function () {      
		if(!Memory.structures[this.id])
			Memory.structures[this.id] = {};
		return Memory.structures[this.id];
    },
	set: function(v) {
		return _.set(Memory, 'structures.' + this.id, v);
	},
	configurable: true,
	enumerable: false
});

// Call this periodically to garbage collect structure memory
// (I find once every 10k ticks is fine)
global.GCStructureMemory = function() {
   for (var id in Memory.structures )
			if(!Game.structures[id]) {
				console.log("Garbage collecting structure " + id + ', ' + JSON.stringify(Memory.structures[id]));
				delete Memory.structures[id];
			}
}
--------------------------------------------
Stick on global with `global.Log = require('Log');` and enjoy
/**
 * Log.js
 *
 * ES6 log class for logging screeps messages with color, where it makes sense.
 * @todo: abbr tag '<abbr title="World Health Organization">WHO</abbr>'
 * @todo: log groups / log levels?
 */
"use strict";

class Log {
	constructor() {
		throw new Error("Log is a static class");
	}

	static debug(msg, tag) {
		this.log(Log.LEVEL_DEBUG, msg, tag);
	}

	static info(msg, tag) {
		this.log(Log.LEVEL_INFO, msg, tag);
	}

	static warn(msg, tag) {
		this.log(Log.LEVEL_WARN, msg, tag);
	}

	static error(msg, tag) {
		this.log(Log.LEVEL_ERROR, msg, tag);
	}

	static success(msg, tag) {
		this.log(Log.LEVEL_SUCCESS, msg, tag);
	}

	/** */
	static log(level = Log.LEVEL_DEBUG, msg, tag) {
		var color = Log.color[level];
		if (tag && this.getLogLevel(tag) > level)
			return;
		this.toConsole(msg, color, tag);
	}

	/**
	 * HTML table in console
	 * ex: Log.table(['a','b'], [[1,2],[3,4]])
	 */
	static table(headers, rows) {

		let msg = '<table>';
		_.each(headers, h => msg += '<th width="50px">' + h + '</th>');
		_.each(rows, row => msg += '<tr>' + _.map(row, el => (`<th>${el}</th>`)) + '</tr>');
		msg += '</table>';
		// console.log(msg);
		return msg;
	}

	/** */
	static notify(msg, group = 0, color = 'red') {
		this.toConsole(msg, color);
		Game.notify(msg, group);
	/** */
	}

		if (!Memory.logging)
	static getLogLevel(tag) {
			Memory.logging = {};
		if (Memory.logging[tag] == null)
			return Log.LEVEL_WARN;
		return Memory.logging[tag];
	}

	/** */
	static toConsole(msg, color, tag) {
		if (tag)
			console.log(`<font color=${color}>[${tag}] ${msg}</font>`);
		else
			console.log(`<font color=${color}>${msg}</font>`);
	}

	/** */
	static progress(v, m) {
		return `<progress value="${v}" max="${m}"/>`;
	}

}

/** Log levels */
Log.LEVEL_DEBUG = 0;
Log.LEVEL_INFO = 1;
Log.LEVEL_WARN = 2;
Log.LEVEL_ERROR = 3;
Log.LEVEL_SUCCESS = 4;

/** Log colors */
Log.color = {
	[Log.LEVEL_DEBUG]: 'yellow',
	[Log.LEVEL_INFO]: 'cyan',
	[Log.LEVEL_WARN]: 'orange',
	[Log.LEVEL_ERROR]: 'red',
	[Log.LEVEL_SUCCESS]: 'green'
};

Object.freeze(Log);
Object.freeze(Log.color);

module.exports = Log;
----------------------------------------------
if (_.sum(creep.carry)) creep.transfer(target, _.last(Object.keys(creep.carry)))
----------------------------------------
global.UNIT_COST = (body) => _.sum(body, p => BODYPART_COST[p]);
global.UNIT_COST = function (body) { return _.sum(body, function (p) { return BODYPART_COST[p]; }); };
----------------------------------------
static exitPlanner(roomName, opts={}) {
		opts = _.defaults(opts, {
			visualize: true,
			commit: false,
		});
		var cm = new PathFinder.CostMatrix;
		var room = Game.rooms[roomName];
		// var visual = room.visual;
		var visual = new RoomVisual(roomName);
		if(room) {
			if(!opts.origin)
				opts.origin = _.create(RoomPosition.prototype, room.memory.origin);
			if(!opts.origin) {
				Log.warn('No origin');
				return;
			}
			var exits = room.find(FIND_EXIT).map(e => ({pos: e, range: 0}));
			room.find(FIND_STRUCTURES).forEach(({pos,structureType}) => {
				if(structureType === STRUCTURE_RAMPART || OBSTACLE_OBJECT_TYPES.includes(structureType))
					cm.set(pos.x,pos.y,255);
			});
		} else {
			console.log('No room object');
		}
		while(true) {
			var {path,incomplete} = PathFinder.search(opts.origin, exits, {roomCallback: () => cm, maxRooms: 1});
			if(incomplete)
				break;
			console.log(JSON.stringify(path));
			var pos = path[path.length-3];
			cm.set(pos.x,pos.y,255);
			var wallOrRampart = (pos.x + pos.y) % 2;
			if(opts.commit){
				var type =  (wallOrRampart?STRUCTURE_WALL:STRUCTURE_RAMPART);
				if(pos.hasStructure(type))
					continue;
				room.addToBuildQueue(pos,type);
			}
			if(opts.visualize) {
				visual.poly(path);
				// visual.circle(pos, {fill:(wallOrRampart?'black':'green'), opacity: 0.75});
				visual.circle(pos, {fill:'red', opacity: 0.75});
			}
		}
	}
----------------------------------------------------
class Pos {
	constructor(x, y) {
		this.x = x;
		this.y = y;
	}
}
Room.prototype.printRoomCosts = function(matrix, proportional = false,  aroundPos = false) {
	let x = 0, y = 0, maxCost = 5, val, line, cost, redHex, greenHex, color;
	let start = new Pos(Math.max(aroundPos && aroundPos.x - 3, 0) || 0,
					  Math.max(aroundPos && aroundPos.y - 3, 0) || 0);
	let end = new Pos(Math.min(aroundPos && aroundPos.x + 3, 49) || 49,
					  Math.min(aroundPos && aroundPos.y + 3, 49) || 49);
	console.log("costs:");
	
	if (proportional) {
	    let xP, yP
	    for (xP = start.x; xP <= end.x; xP++) {
	        for (yP = start.y; yP <= end.y; yP++) {
	            cost = matrix.get(xP, yP);
	            if (cost < 250 && cost > maxCost) {
	                maxCost = cost;
	            }
	        }
	    }
	    console.log(maxCost);
	}
	
	for (y = start.y; y <= end.y; y++) {
		line = '';
		for (x = start.x; x <= end.x; x++) {
		    val = Math.min(matrix.get(x, y) + 1, maxCost) * Math.floor(256 / maxCost);
		    redHex = (val).toString(16);
		    greenHex = (256 - val).toString(16);
		    color = ( redHex[1] ? redHex : '0' + (redHex[0] || '0') )+
		            (greenHex[1] ? greenHex : '0' + (greenHex[0] || '0') ) +
		            '00';
			line += '<a style="color: #' + color + '">âââ</a>';
		}
		console.log(line);
	}
}
----------------------------------------
	creep.pos.findClosestByRange(FIND_DROPPED_RESOURCES, {filter{resourceType:RESOURCE_POWER});
----------------------------------------------
	doStats: {
        run: function () {
            Memory.stats = {
                tick: Game.time,
                cpu: _.cloneDeep(Game.cpu),
                gcl: Game.gcl,
                constructionSites: _.size(Game.constructionSites),
                tokens: Game.resources.token,

                memory: {
                    used: RawMemory.get().length
                },

                market: {
                    credits: Game.market.credits,
                    num_orders: Game.market.orders ? Object.keys(Game.market.orders).length : 0,
                }

            }
        }
    }
-----------------------------------------------
	function mayReserveController(theController) {
    if (theController.owner) {
        return false;
    }
    if (!theController.reservation) {
        return true;
    }
    if (theController.reservation.username != 'Dissi') {
        return false;
    }
    if (theController.reservation.ticksToEnd < 2500) {
        return true;
    }
    return false;
}
-------------------------------------
global.spiralOut = function(n){
    let m=n+1;
    let result = [];
    for (let i=0; i<=49; i++ ){
        if (i % 2 === 0 || m > 49){
            result[i]=n;
            n--;
            continue;
        }
        result[i]=m;
        m++;
    }
    return result;
},
