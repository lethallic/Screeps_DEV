1. 	TODO
    	- Behavior Transport Minerals to Terminal
    	- Behavior Harvest Minerals
		- When storage > 100000 energy -> Prefer other link :-)
		- Remote Mining (check for goals, new behavior)
		- Upgrader - TravelTo - Range = 2 
    	- Rework Scout. 1 scout with claim parts, rest without (Claim Part Creeps die quicker and are expensive)
		- 2 Upgrader if Dropped energy around Controller > 5000 ?
		-- Sell + Buy at Market
    	-- Scout could dismantle buildings in target room?
    	-- Harvest Power
    	-- renew boosted creeps
		-- test attack behavior
		-- spawn defenders if attacked
    	-- Boost creeps
   	BUGS
	    - (bug) Limit Tower repair - based on what? 5 ticks?
	    - (bug) when controller downgrades during construction, workers can't finish behavior construction
		- (bug) Fallback if no creeps in active room (Implemented but fails?)
   	TESTING
    	- (test) (bug) Upgrade Rampart hört nicht auf wenn max erreicht ist. fix: Hardcoded value durch maxHits ersetzt.
		- (test) Separate role for upgrader in RCL 1+2+ (3?) (Activated in RCL2)
    	- (test) Behavior Pickup Minerals (only dropped minerals - nope, walks directly to mineral source)
  	DONE
		- (done) When storage > 100000 energy - no more input. Fix -> maxE based on constants + rcl
		- (done) Check Scout Code
    	- (done) Upgrader Link -> Storage
    	- (done) Behavior Repair Container
    	- (done) Behavior Get_energy_container (done)
		- (done) (bug) Tower Repair + Heal (repair ready, but not activated in ControllerRoom)
		- (done) (bug) Filling Storage does not work with new checks. Why?	
    

2. Code Snippets

Object.defineProperty(Source.prototype, “memory”, {
  configurable: true,
  get() {
    if (_.isUndefined(this.room.memory.sources)) {
      this.room.memory.sources = {};
    }
    return this.room.memory.sources[this.id] = this.room.memory.sources[this.id] || {};
  },
  set(value) {
    if (_.isUndefined(this.room.memory.sources)) {
      this.room.memory.sources = {};
    }
    if (!_.isObject(Memory.structure)) {
      throw new Error(“Could not set structure memory”);
    }
    this.room.memory.sources[this.id] = value;
  },
});

----------------------------------------
Object.defineProperty(Source.prototype, 'memory', {
    configurable: true,
    get: function() {
        if(_.isUndefined(Memory.mySourcesMemory)) {
            Memory.mySourcesMemory = {};
        }
        if(!_.isObject(Memory.mySourcesMemory)) {
            return undefined;
        }
        return Memory.mySourcesMemory[this.id] = 
                Memory.mySourcesMemory[this.id] || {};
    },
    set: function(value) {
        if(_.isUndefined(Memory.mySourcesMemory)) {
            Memory.mySourcesMemory = {};
        }
        if(!_.isObject(Memory.mySourcesMemory)) {
            throw new Error('Could not set source memory');
        }
        Memory.mySourcesMemory[this.id] = value;
    }
});

----------------------------------------
Object.defineProperty(Source.prototype, 'freeSpaceCount', {
    get: function () {
        if (this._freeSpaceCount == undefined) {
            if (this.memory.freeSpaceCount == undefined) {
                let freeSpaceCount = 0;
                [this.pos.x - 1, this.pos.x, this.pos.x + 1].forEach(x => {
                    [this.pos.y - 1, this.pos.y, this.pos.y + 1].forEach(y => {
                        if (Game.map.getTerrainAt(x, y, this.pos.roomName) != 'wall')
                                freeSpaceCount++;
                            }, this);
                    }, this);
                this.memory.freeSpaceCount = freeSpaceCount;
            }
            this._freeSpaceCount = this.memory.freeSpaceCount;
        }
        return this._freeSpaceCount;
    },
    enumerable: false,
    configurable: true
});
----------------------------------------

static exitPlanner(roomName, opts={}) {
		opts = _.defaults(opts, {
			visualize: true,
			commit: false,
		});
		var cm = new PathFinder.CostMatrix;
		var room = Game.rooms[roomName];
		// var visual = room.visual;
		var visual = new RoomVisual(roomName);
		if(room) {
			if(!opts.origin)
				opts.origin = _.create(RoomPosition.prototype, room.memory.origin);
			if(!opts.origin) {
				Log.warn('No origin');
				return;
			}
			var exits = room.find(FIND_EXIT).map(e => ({pos: e, range: 0}));
			room.find(FIND_STRUCTURES).forEach(({pos,structureType}) => {
				if(structureType === STRUCTURE_RAMPART || OBSTACLE_OBJECT_TYPES.includes(structureType))
					cm.set(pos.x,pos.y,255);
			});
		} else {
			console.log('No room object');
		}
		while(true) {
			var {path,incomplete} = PathFinder.search(opts.origin, exits, {roomCallback: () => cm, maxRooms: 1});
			if(incomplete)
				break;
			console.log(JSON.stringify(path));
			var pos = path[path.length-3];
			cm.set(pos.x,pos.y,255);
			var wallOrRampart = (pos.x + pos.y) % 2;
			if(opts.commit){
				var type =  (wallOrRampart?STRUCTURE_WALL:STRUCTURE_RAMPART);
				if(pos.hasStructure(type))
					continue;
				room.addToBuildQueue(pos,type);
			}
			if(opts.visualize) {
				visual.poly(path);
				// visual.circle(pos, {fill:(wallOrRampart?'black':'green'), opacity: 0.75});
				visual.circle(pos, {fill:'red', opacity: 0.75});
			}
		}
	}
----------------------------------------------------
class Pos {
	constructor(x, y) {
		this.x = x;
		this.y = y;
	}
}
Room.prototype.printRoomCosts = function(matrix, proportional = false,  aroundPos = false) {
	let x = 0, y = 0, maxCost = 5, val, line, cost, redHex, greenHex, color;
	let start = new Pos(Math.max(aroundPos && aroundPos.x - 3, 0) || 0,
					  Math.max(aroundPos && aroundPos.y - 3, 0) || 0);
	let end = new Pos(Math.min(aroundPos && aroundPos.x + 3, 49) || 49,
					  Math.min(aroundPos && aroundPos.y + 3, 49) || 49);
	console.log("costs:");
	
	if (proportional) {
	    let xP, yP
	    for (xP = start.x; xP <= end.x; xP++) {
	        for (yP = start.y; yP <= end.y; yP++) {
	            cost = matrix.get(xP, yP);
	            if (cost < 250 && cost > maxCost) {
	                maxCost = cost;
	            }
	        }
	    }
	    console.log(maxCost);
	}
	
	for (y = start.y; y <= end.y; y++) {
		line = '';
		for (x = start.x; x <= end.x; x++) {
		    val = Math.min(matrix.get(x, y) + 1, maxCost) * Math.floor(256 / maxCost);
		    redHex = (val).toString(16);
		    greenHex = (256 - val).toString(16);
		    color = ( redHex[1] ? redHex : '0' + (redHex[0] || '0') )+
		            (greenHex[1] ? greenHex : '0' + (greenHex[0] || '0') ) +
		            '00';
			line += '<a style="color: #' + color + '">███</a>';
		}
		console.log(line);
	}
}
----------------------------------------------
// These toString() functions provide an option to provide an HTML link to click in the console. The link will bring you to the room the object is in, highlight the object and load a temporary memory watch in the Memory tab for that object.

RoomPosition.prototype.toString = function (htmlLink = true, id = undefined, memWatch = undefined) {
    if(htmlLink){
        var onClick = '';
        if(id)       onClick += `angular.element('body').injector().get('RoomViewPendingSelector').set('${id}');`;
        if(memWatch) onClick += `angular.element($('section.memory')).scope().Memory.addWatch('${memWatch}'); angular.element($('section.memory')).scope().Memory.selectedObjectWatch='${memWatch}';`;
        return `<a href="#!/room/${this.roomName}" onClick="${onClick}">[${ this.roomName } ${ this.x },${ this.y }]</a>`;
    }
    return `[${ this.roomName } ${ this.x },${ this.y }]`;
};


Creep.prototype.toString = function (htmlLink = true){
    return `[${(this.name ? this.name : this.id)} ${this.pos.toString(htmlLink, this.id, 'creeps.'+this.name)}]`;
}

Structure.prototype.toString = function (htmlLink = true){
    return `[structure (${this.structureType}) #${this.id} ${this.pos.toString(htmlLink, this.id, 'structures.' + this.id)}]`;
}

StructureSpawn.prototype.toString = function (htmlLink = true){
    return `[spawn ${this.name} ${this.pos.toString(htmlLink, this.id, 'spawns.' + this.name)}]`;
}
---------------------------------------------------------
 var allowedNameList = ["foo", "Source Keeper", "bar", "Invader"]
    var targetList = Game.rooms['sim'].find(FIND_HOSTILE_CREEPS, {
        filter: function(foundCreep) { 
            for (let i=allowedNameList.length;--i>=0;){
                if (foundCreep.owner.username === allowedNameList[i]) return(false);
            }
            return(true);
        }
    });
    if (targetList.length !== 0) console.log("Run in circles! Scream and shout!");